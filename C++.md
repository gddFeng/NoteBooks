# 1.1 C++简介

## 1.1.1 C++的发展简史

### 1.1.1.1 课程介绍

#### 书籍介绍

* C++ Prime 
* 大话数据结构
  
### 1.1.1.2 编程环境

推荐使用Visual Studio 2019 

不过我用的是VS Code

### 1.1.1.3 C++发展史

前期的阶段老师没讲

#### 重要的C++版本

* C++98
* C++11
* C++20

我们学的是C++11版本的

同时编译器使用的是2019版本的，因为编译器往往需要过两年才能适配新版本的语法。

#### C++的主要用途

- 服务器端编程
- 算法设计
- 通过Qt进行Linux、国产化操作系统的桌面应用程序开发，自主可控的软件开发。

## 1.1.2 C++的特点

### 1.1.2.1支持四种编程范式

Java号称是纯面向对象的语言，他的main封装在class类里面。

四种编程范式：面向过程、面向对象、泛型编程、函数式编程

* 面向过程
    * 瀑布式开发模型
        * 其实就是正常的程序流程构设
        * 非常理想化，没有考虑在实际开发过程中可能产生的需求变化和将来的软件升级。
        * 在软件开发过程中唯一不变的是变化！
* 面向对象，OOP(Object-Oriented Programming)
    * 三个基本特征：封装、继承、多态
* 泛型编程 
    * 与类型无关的编程，是通过模板实现的。以模板为基础，STL实现通用的容器类。
    * 感觉上就是调用库。
* 函数式编程

### 1.1.2.2 适合编写大型应用程序

1. 不适合编写操作系统，操作系统的内核还是由C语言完成的。
2. C++的一些语法设计，考虑了很多人同时开发，例如命名空间namespace。
3. 面向对象程序设计（OOP），根本上解决了需求发生变化、软件升级的问题

### 1.1.2.3 可复用、可扩充、可维护和灵活性好

### 1.1.2.4 C++的缺点

* C++的强大在于提供高级抽象的同时又不放弃对程序的细节控制。
* 过于频繁的更换，除了增加功能以外，也使得C++变得越来越复杂。苦了人脑，幸福电脑。

# 1.2 第一个C++程序

## 1.2.1 Hello World

```C++
#include <iostream>
int main(){
    std::cout<<"Hello World!\n";
}
```

### 1.2.1.1 C++与C的不同

1. 头文件没有后缀名
2. C++兼容C，可以在C语言头文件名称前加上**c**后去除后缀名进行引用。
3. 基本输出不同
   
```C++
std::cout << "Hello,World!\n";
//std::cout是标准命名空间中定义、ostream类型的全局变量，代表显示器。
```

* std是标准命名空间（standard）
* ::是域操作符（相当于的）
* cout是控制台输出设备
* <<是输出运算符

# 1.3 C++对C语言的扩充

## 1.3.1 命名空间

为了解决合作开发时命名冲突的问题，C++引用了命名空间。

```C++
namespace Li{
    int a=100;
    void printInt(){std::cout << a << std::endl;}
    //endl是标准命名空间定义的换行符
}
namespace Han{
    int a=200;
    void printInt(){std::cout << a << std::endl;}
}
```

在不同的namespace中可以重复定义相同的函数或相同的变量。

```C++
//调用
int main(){
    Han::a = 300;
    Li::printInt();//输出100
    Han::printInt();//输出300
}
```

### 1.3.1.1 命名空间简写方法

1. 使用 **::** 引用命名空间中定义的元素
`std::cout << "C++" << std::endl;`
2. 使用using引用命名空间中的某个元素

```C++
using std::cout;
cout << "C++" << std::endl;
```

3. 使用using引用命名空间
```C++
using namespace std;
cout << "C++" << endl;
```

## 1.3.2  控制台输入输出

### C++的I/O解决方案

* 使用 **cin** 接收从键盘输入的数据，用 **cout** 向屏幕上输出数据（这2个过程又称为“标准I/O”）。
* C++也对从文件中读取数据和向文件中写入数据做了支持（统称为“文件I/O”）。

### C++标准库中包含了“流类”

* istream：常用语接收从键盘输入的数据；
* ostream：常用语将数据输出到屏幕上；
* ifstream： 用于读取文件中的数据；
* ofstream： 继承自istream和ostream类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出；
* fstream：兼ifstream和ofstream类功能于一身，既能读取文件中的数据，又能向文件中写入数据。
* cin是istream类的对象，cout是ostream类的对象，在<iostream>头文件中声明。
* 使用cin和cout需要包含<iostream>头文件，当然还需要使用std命名空间。

### 输入

* 输入流对象cin和输入运算符>>配合，用于用户输入
* 在连续输入多个变量时，以空白(空格、回车、制表符)为分隔符
  
```C++
int a,b;
cin>>a>>b;
//如果是字符型的话，分隔符会被识别成数据。
```

###  输出

* 输出对象cout和输出运算符<<配合，用于用户输出
* 可以连续输出多个不同类型的常量或变量

```C++
cout<<"Hello,C++"<<endl;
//注意流的方向，要指向cout
```

1. **两个运算符都是从左向右结合**
2. cin>>a的返回值时cin,cout>>"Hello,C++"的返回值是cout。所以可以连续执行。

### 小例子

```C++
#include<iostream>
using namespace std;
int main(){
    int a=0,b=0;
    cout << "Please Enter Two Integers:"
    cin >>a >> b;
    cout << a << "+" << b << "=" << a+b <<endl; 
}
```

C语言中的`scanf`是不安全的函数，如果要使用需要`#define _CRT_SECURE_NO_WARNINGS`

## 1.3.3 增强类型

1. const常变量
2. bool布尔类型
3. enum枚举类型

### 1.3.3.1 const的基本概念

* 定义只读变量的关键字

```C++
const int a = 100;
//const的量一定要赋值进行初始化
const int * pa = &a;
 //const int * 类型的值不能用于初始化int*类型的实体
```

* 在C语言中const变量不能定义数组长度，但是在C++中可以。

```C++
const int size = 100;
int arr[size];
```

### 1.3.3.2 const与指针

* 指向整型变量的指针且指向的值不能修改的**常量指针**
    * 解释：所指的变量不能被修改。被称为**指针常量**
    * const int * p;
    * int const * p;
    * 当使用是形参时，传入变量地址就可以。
* 指向整型变量的指针，但不能指向其他变量
    * int * const p
    * 解释：只能指向某一变量，设定后无法更改。
    * 数组就是**指针常量**
* 指向整型常量的指针常量
    * const int * const p;

## 1.3.3 布尔类型

在C语言的C99版本中可以引用<stdbool.h>来使用bool类型

* enum

```C++
enum SEASON{SPRIG,SUMMER,AUTUMN,WINTER};
SEASON s1 = SUMMER；
```

## 1.3.4 参数默认值

直接在形参中初始化

```C++
#include<iostream>
using namespace std;
void add(int x,int y=1,int z=2){
    cout<<x+y+z<<endl;
}
int main(){
    add(1);     //4
    add(1,2);   //5
    add(1,2,3); //6
    return 0;
}
```

1. 参数默认值可在函数声明中出现一次，如果没有函数声明，只有函数定义，那么可以在函数定义中设定

```C++
//fun.h
int Add(int a,int b=1,int c=2);
//fun.cpp
int Add(int a,int b,int c){
    return a+b+c;
}
```

1. 默认参数赋值的顺序时自右向左

```C++
int Add(int a,int b=0,int c)
//这种是错的
```

## 1.3.5 函数重载

* 所谓函数重载，是指在同一个作用域内、函数名相同、参数列表不同的多个函数。
* 编译器会根据所给的参数自动选择相应的函数。
* 参数列表不同：
    1. 参数类型不同
    2. 参数个数不同
    3. 参数类型、个数均不同
    * **形参变量名不同不构成重载！**
* 当重载函数有默认值时，要防止二义性！
    * 两个同名函数之间，只差若干个默认值，当未指定默认值时，程序就不知道使用哪个函数了。

## 1.3.6 引用

### 1.3.6.1 引用的基本概念

* 引用就是给变量取的一个别名

```C++
int a = 100;
int &ra = a;
ra = 200;
cout<<a<<endl;
```

* 引用的语法
    * 类型 & 引用名 = 变量名；
* &的含义
    1. int & ra = a;    在定义变量的时候使用&，表示引用
    2. int *p;p=&a;     一元操作，表示取地址
    3. a & b;           二元运算符，表示运算中的按位与
    4. a && b;            表示逻辑与
* 使用引用的注意事项
    1. 引用必须初始化
    2. 不能引用常量
    3. 不能引用数组
    4. 引用只能时某个固定变量的引用，不能再引用其他变量。
* 没必要在一个函数内使用引用，通常在两个函数之间使用引用
    * 形参是引用
        * 在C语言中，函数参数的两种形式
            * 传值
            * 传地址
    * 返回值是引用

### 1.3.6.2 函数参数的三种形式

#### 1. 传值

``` C++
void Swap1(int x,int y){int temp=x;x=y;y=temp}
int main(){
    int a=100,b=200;
    Swap1(a,b);
}
```
* 传值，子函数无法改变调用函数中变量的值。
* 每个函数的一次运行都会有一个自动分配的栈，局部变量位于栈中。形参也是局部变量。
  
函数每一次运行都会有一个独立的栈，用来存放局部变量。这就导致了`主函数`和`自定义函数`中分别定义的变量不互通，主函数传入变量的时候仅仅传入了值，而非变量本身。

#### 2. 传地址

```C++
void Swap2(int *p,inty *q){int temp=*p;*p=*q;*q=temp;}
int main(){
    int a=100,b=200;
    Swap2(&a,&b);
}
```

* 传地址，子函数可以修改调用函数中变量的值
* 下面是比较常见的初学者的错误写法

```c++
Swap3(int *p,int *q){int *temp=p;p=q;q=temp;}
```

这种方式直接传输地址，使得不同函数可以直接读取或写入`其他函数栈`中`相应地`址的`变量`。

#### 3. 传引用

```C++
void Swap4(int &x,int &y){int temp=x;x=y;y=temp}
int main(){
    int a=100,b=200;
    Swap4(a,b);
}
```

* 传引用，可以达到传指针同样的效果，但是调用更方便。
* 与传地址不同的地方就是函数定义不是`*x`了，而是`&x`，这样传入的可以直接传入变量
* 个人理解：直接将传入函数`命名别名`后，在函数中进行使用。
* 尽管在形参中没有认为进行初始化，但是`从形参到实参的过程就是初始化！`

### 1.3.6.3 引用——函数的返回值

不会在一个函数内部使用引用，引用仅应用于两个函数之间

1. 函数参数是引用类型
2. 函数的返回值是引用

```C++
int & At(int b[],int index){
    return b[index];
}
int main(){
    int a[3] = {1,2,3};
    At(a,1) = 100;
    //b[index]等价于a[1]
    //等价于a[1] = 100
}
```

* 也就是说，可以让`函数调用作为左值`。
* 可以避免返回值被拷贝
* 注意：不能返回局部变量的引用
    * 因为局部变量存在函数的栈中，函数一旦运行结束，栈会被释放清空，那么这个数据就不存在了。

### 1.3.6.4 引用——常引用

* int & a=b;a就是b。
* 针对引用类型的函数参数，形参就是实参。这带来两种用途：
    1. 子函数可以通过引用类型的参数来修改调用函数中的变量，并且不用使用指针（都不喜欢指针，能不用尽量不用）。
    2. 避免了形参到实参的初始化过程，从而提高了效率。
* 如果只想2，而不想1，可以使用`常引用`
```C++
void fun(const XYZ & r){……}
```
* 在面向对象编程中，类类型属于自定义类型，比简单类型占用更多的内存空间。如果函数的参数类型是类类型，为了提高效率，我们往往使用常引用。

## 1.3.7 内存管理——堆、栈

* 不是数据结构中的堆和栈

1. C语言的内存区域
   * 堆
       * 堆是用于存放进程运行中被动态分配的`内存段`。当进程调用`malloc/free`等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被剔除（堆被缩减）。
   * 栈
       * 栈又称堆栈，存放`程序的局部变量`(但不包括static声明的变量)和`函数被调用时的参数和返回值`。

* 从低位地址到高位地址逐个是：

  1. 代码区：函数代码块的二进制代码。
  2. 数据区
  3. 文字常量区：常量字符串存放于此
  4. 未初始化静态变量区：没有初始化的全局变量和静态变量
  5. 已初始化的静态变量区：初始化的全局变量和静态变量
  6. 堆区：动态分配的数据
  7. 栈区：局部变量存放于此
  8. 命令行参数区：命令行参数和局部变量

2.  C++内存区域
   * C++中内存分成5个区：
        1. 栈：内存由编译器在需要时`自动`分配和释放。通常用来存储局部变量和函数参数。（为运行函数而分配的局部变量、函数参数、返回地址等存放在`栈区`）
        2. 堆：内存使用`new`进行分配，使用`delete`释放。如果未能对内存进行正确的释放，会造成`内存泄漏`。
        3. 自由存储区：使用`malloc`进行分配，使用`free`进行回收。
        4. 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，C语言中区分初始化和未初始化的，C++中不再区分了。(全局变量、静态数据、常量存放在`全局数据区`)
        5. 常量存储区：存储常量，不允许被修改。
* 栈和堆的对比
  * 栈
    1. 内个函数的第一次运行都会有一个独立的栈
    2. 自动分配、自动释放
    3. 通过变量直接使用
  * 堆
    1. 全局只有一个堆
    2. 手动分配、手动释放
    3. 通过指针间接使用

```C++
void fun(){
    int a = 0;
    a++;
}//函数运行结束，栈被自动释放
int main(){
    fun();
    fun();
}
//运行了两次，有两个栈，栈中的a都为1
```
```C++
void fun(){
    int * p =new int;
    //这里*p是局部变量，存在栈中。同时堆中开辟了一块int类型大小的空间。
    *p = 100;//p指向的内存单元为100，也就是堆中相应内存单元为100.
    delete p;
    //将堆中数据回收，但*p还在，仍然指向堆中的那个地址，称为“野指针”
}
```

## 1.3.8 new/delete

* 在C语言中，动态分配内存用`malloc()`函数，释放内存用`free()`函数。
```C++
int *p = (int*)malloc(sizeof(int));//分配一个int型的内存空间
//将int大小的空间分配给p并将无类型的p进行强制类型转换
free(p);//释放内存
//分配在堆中
```

* C++新增了两个关键字，使用起来更简介
  * `new`用来动态分配内存
```C++
int *p = new int;//分配一个int型的内存空间
```
  * delete用来释放内存
```C++
delete p;
```

1. 根据后面的数据类型来`自动推断所需空间大小`
2. 返回具体类型的指针，不需要进行类型转换

* 分配一组连续的数据（动态数组）
  * C语言版本
```C
int *p = (int *) malloc(sizeof(int)*10);
free(p);
```
  * 版本
```C++
int *p = new int[10];
delete []p;
```

* new/delete的优点
  * `new`可以自动推断所需空间大小，而`malloc`需要通过`sizeof`进行计算。
  * `new`自动返回所需类型指针，而`malloc`返回的是`void *`，还需要类型转换
  * `new`在分配空间的同时还可以初始化，而`malloc`只能分配空间
```C++
int *p = new int(100);
//将p初始化为100
```
  * 我们可以笼统的说`new`和`malloc`都是在`堆`中分配内存，但仍然有差别，所以`new/delete`和`malloc/free`不能混用。
  * `new/delete`支持C++的新特性，包括：重载、调用构造/析构函数。

## 1.3.8 静态数组、动态数组

* 静态数组
```C
const int SIZE = 100;//SIZE是常量
int a[SIZE]; // 定义数组时，数组的大小必须是常量
```
* 动态数组
```C++
int size = 100;//size是变量
int *p = new int[size];//可以在内存中分配任意大小的内存
```
* 指针p和数组名a都指向内存中一段内存的首地址，且用法都是一样的
```C++
*(a+10)=123;
p[10]=123;
//相互等价
```
* 差别在于，a是`指针常量`，p是`指针变量`,`p++`可以，`a++`不行。



